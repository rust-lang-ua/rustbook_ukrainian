## Усі Місця Можливого Використання Шаблонів

Шаблони з’являються в багатьох місцях в Rust, і ви ними багато користуєтеся навіть не підозрюючи про це! В цьому розділі ми розглянемо всі місця, де допускаються шаблони.

### Рукави Виразу `match`

Як обговорювалося в Розділі 6, ми використовуємо шаблони в рукавах виразів `match`. Формально, вирази `match` визначені як ключове слово `match`, значення яке буде зіставлятися та один або більше рукавів зіставлення, що складаються з шаблону та виразу для виконання, якщо значення зіставляється зі шаблоном рукава, як тут:

```text
match VALUE {
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
}
```

For example, here's the `match` expression from Listing 6-5 that matches on an `Option<i32>` value in the variable `x`:

```rust,ignore
match x {
    None => None,
    Some(i) => Some(i + 1),
}
```

Шаблони в цьому виразі `match` це `None` та `Some(i)` ліворуч від кожної стрілки.

Одна з вимог виразів `match` це необхідність бути *вичерпним* у сенсі, що всі можливі значення виразу `match` повинні бути враховані. Один зі способів переконатися, що ви охопили всі можливі варіанти, - це мати загальний шаблон для останнього рукава: наприклад, назва змінної, що збігається з будь-яким значенням, не може не спрацювати і, таким чином, охоплює всі варіанти, що залишилися.

Зокрема, шаблон `_` буде відповідати будь-чому, але він ніколи не зв'язується зі змінною, тому його часто використовують в останньому рукаві виразу match. Шаблон `_` може бути корисним, наприклад, коли потрібно ігнорувати будь-яке не вказане значення. Ми розглянемо шаблон `_` більш детально в секції ["Ігнорування Значень в Шаблоні"]()<!-- ignore --> пізніше в цьому розділі.

### Умовні Вирази `if let`

В Розділі 6 ми обговорювали використання виразів `if let` в основному як рівнозначний та коротший спосіб написання `match`, який лише зіставляється в одному випадку. При необхідності, `if let` може мати відповідний `else`, що містить код для виконання на випадок невідповідності шаблону в `if let`.

В Блоці Коду 18-1 показано, що також можливо поєднувати вирази `if let`, `else
if`, та `else if let`. Це надає нам більшу гнучкість, ніж вираз `match`, в якому ми можемо представити тільки одне значення для порівняння з шаблонами. Також Rust не вимагає, щоб умови в послідовності `if let`, `else if`, `else if let` стосувалися одна одної.

Код у Блоці Коду 18-1 визначає, яким кольором зробити ваш фон, виходячи з низки перевірок за кількома умовами. Для цього прикладу ми створили змінні з жорстко заданими значеннями, які справжня програма може отримати з вхідних даних користувача.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-01/src/main.rs}}
```


<span class="caption">Блок Коду 18-1: Змішування `if let`, `else if`, `else if let`, та `else`</span>

Якщо користувач вказує улюблений колір, цей колір використовується як фоновий. Якщо улюблений колір не вказано і сьогодні Вівторок, то фоновим кольором буде зелений. Інакше, якщо користувач вказує свій вік стрічкою і ми можемо успішно розібрати її як число, то колір буде фіолетовим або помаранчевим в залежності від значення числа. Якщо жодна з цих умов не застосовується, колір фону буде синім.

Ця умовна структура дозволяє нам підтримувати складні вимоги. З жорстко заданими значеннями як ми маємо тут, цей приклад виведе в консолі `Використовую фіолетовий колір як колір фону`.

Ви можете побачити, що `if let` також може впроваджувати затінені змінні аналогічним чином що і рукави `match`: рядок `if let Ok(age) = age` запроваджує нову затінену змінну `age`, яка містить значення всередині `Ok`. Це означає, що нам потрібно помістити умову `if age > 30` в цей блок: ми не можемо об'єднати ці дві умови в `if let Ok(age) = age && age > 30`. Значення затіненої змінної `age`, яку ми хочемо порівняти з 30, не дійсне до тих пір, поки не почнеться новий діапазон з фігурної дужки.

Недоліком використання виразів `if let` є те, що компілятор не перевіряє вичерпність, тоді як при використанні виразів `match` він це робить. Якби ми пропустили останній блок `else` і, відповідно, пропустили обробку деяких випадків, компілятор не попередив би нас про можливу логічну помилку.

### Умовні Цикли `while let`

Подібно до конструкції `if let`, умовний цикл `while let` дозволяє циклу `while` працювати допоки шаблон продовжує збігатися. У Блоці Коду наведено код циклу `while let`, який використовує вектор як стек і виводить в консолі значення вектора у зворотному порядку, в якому вони були додані.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-02/src/main.rs:here}}
```


<span class="caption">Блок Коду 18-2: Використання циклу `while let` для виводу значень в консоль, допоки `stack.pop()` повертає `Some`</span>

Цей приклад виводить в консолі 3, 2, і потім 1. Метод `pop` бере останній елемент з вектора і повертає `Some(значення)`. Якщо вектор порожній, `pop` поверне `None`. Цикл `while` продовжує виконання коду в своєму блоці допоки `pop` повертає `Some`. Коли `pop` поверне `None`, цикл зупиниться. Ми можемо використовувати `while let` для вилучення кожного елементу зі стека.

### Цикли `for`

В циклі `for`, значення яке безпосередньо слідує за ключовим словом `for` є шаблоном. Наприклад, `x` в `for x in y` є шаблоном. Блок Коду 18-3 демонструє як використовувати шаблон в циклі `for` для деструктуризації або розбирання на частини кортежу, як частини циклу `for`.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-03/src/main.rs:here}}
```


<span class="caption">Блок Коду 18-3: Використання шаблону в циклі `for` для деструктуризування кортежу</span>

Код в Блоці Коду 18-3 виведе в консоль наступне:

```console
{{#include ../listings/ch18-patterns-and-matching/listing-18-03/output.txt}}
```

Ми адаптуємо ітератор використовуючи метод `enumerate` таким чином, щоб він генерував значення та індекс для цього значення, поміщені в кортеж. Перше згенероване значення - кортеж `(0, 'a')`. При зіставленні цього значення з шаблоном `(index, value)`, `index` буде `0`, а `value` буде `'a'`, виводячи перший рядок виводу в консоль.

### Інструкції `let`

До цього розділу ми явно обговорювали тільки використання шаблонів з `match` та `if let`, але насправді ми використовували шаблони і в інших місцях, в тому числі і в операторах `let`. Наприклад, розглянемо це просте присвоювання змінної з використанням `let`:

```rust
let x = 5;
```

Кожного разу, коли ви використовували інструкцію `let`, ви використовували шаблони, хоча, можливо, ви цього навіть не усвідомлювали! Більш формально, оператор `let` виглядає так:

```text
let PATTERN = EXPRESSION;
```

В інструкціях типу `let x = 5;` з назвою змінної в слоті `PATTERN` назва змінної є лише особливо простою формою шаблону. Rust порівнює вираз із шаблоном і призначає будь-які знайдені імена. Таким чином, у прикладі `let x = 5;` `x` - це шаблон, який означає "прив'язати до змінної `x` все, що зіставляється з цим виразом." Оскільки назва `x` - це весь шаблон, цей шаблон фактично означає "прив'язати все до змінної `x`, незалежно від її значення."

To see the pattern matching aspect of `let` more clearly, consider Listing 18-4, which uses a pattern with `let` to destructure a tuple.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-04/src/main.rs:here}}
```


<span class="caption">Блок Коду 18-4: Використання шаблону для деструктуризації кортежу та створення трьох змінних одразу</span>

Тут ми зіставляємо кортеж з шаблоном. Rust зіставляє значення `(1, 2, 3)` із шаблоном `(x, y, z)` та бачить, що значення зіставляються, тому Rust пов'язує `1` до `x`, `2` до `y` та `3` до `z`. Ви можете думати про цей шаблон кортежу як про три окремих вкладених шаблонів змінних всередині.

Якщо кількість елементів у шаблоні не відповідає кількості елементів у кортежі, то загальний тип не буде збігатися і ми отримаємо помилку компілятора. Наприклад, у Блоці Коду 18-5 показано спробу деструктуризації кортежу з трьома елементами на дві змінні, що не спрацює.

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-05/src/main.rs:here}}
```


<span class="caption">Блок Коду 18-5: Неправильна побудова шаблону, змінні якого не відповідають кількості елементів у кортежі</span>

Спроба скомпілювати цей код призведе до помилки цього типу:

```console
{{#include ../listings/ch18-patterns-and-matching/listing-18-05/output.txt}}
```

Щоб виправити помилку, ми можемо проігнорувати один або більше значень кортежу, використовуючи `_` або `..`, як ви побачите в секції ["Ігнорування Значень в Шаблоні"]()<!-- ignore --> . Якщо проблема в тому, що в шаблоні занадто багато змінних, то рішення полягає в узгодженні типів шляхом видалення змінних так, щоб кількість змінних дорівнювала кількості елементів в кортежі.

### Параметри Функції

Параметри функції також можуть бути шаблонами. Код у Блоці Коду 18-6, який оголошує функцію з назвою `foo`, яка отримує один параметр з назвою `x` типу `i32`, вже повинен виглядати знайомим.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-06/src/main.rs:here}}
```


<span class="caption">Блок Коду 18-6: Сигнатура функції використовує шаблони в параметрах</span>

Частина `x` - це шаблон! Ми можемо зіставляти кортеж в аргументах функції із шаблоном, як ми зробили з `let`. В Блоці Коду 18-7 значення кортежу розділяються, коли ми передаємо їх до функції.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-07/src/main.rs}}
```


<span class="caption">Блок Коду 18-7: Функція з параметрами, які розкладають кортеж</span>

Цей код виводить в консоль `Current location: (3, 5)`. Значення `&(3, 5)` зіставляються з шаблоном `&(x, y)`, тому `x` має значення `3` та `y`має значення `5`.

Ми також можемо використовувати шаблони в списках параметрів замикань, так само як в списках параметрів функцій, оскільки замикання схожі до функцій, як обговорювалося в Розділі 13.

Наразі ви побачили декілька способів використання шаблонів, але вони не працюють однаково у всіх місцях можливого використання. У деяких місцях шаблони мають бути неспростовні; в інших умовах вони можуть бути спростовними. Ми обговоримо ці дві концепції далі.
ch18-03-pattern-syntax.html#ignoring-values-in-a-pattern
