## `RefCell<T>` і шаблон внутрішньої мутабельності

*Внутрішня мутабельність* - це шаблон проєктування в Rust, що дозволяє вам змінювати дані, навіть якщо є немутабельні посилання на ці дані; зазвичай, ця дія заборонена правилами позичання. Щоб змінювати дані, цей шаблон використовує `небезпечний` код у структурі даних, щоб обійти звичайні правила Rust, що керують мутабельністю та позичанням. Небезпечний код повідомляє компілятор, що ми перевіряємо правила самостійно, а не покладаємося на компілятор, щоб перевіряти їх для нас; ми детальніше поговоримо про небезпечний код у Розділі 19.

Ми можемо використовувати типи, які використовують шаблон внутрішньої мутабельності тільки тоді, коли ми можемо гарантувати дотримання правил позичання під час виконання, тоді як компілятор не може гарантувати цього. `Небезпечний` код застосовується загорнутим у безпечне API, і зовнішній тип лишається немутабельним.

Дослідимо цю концепцію, розглянувши тип `Refell<T>`, який слідує шаблону внутрішньої мутабельності.

### Забезпечення правил позичання під час виконання за допомогою `RefCell<T>`

На відміну від `Rc<T>`, тип `RefCell<T>` представляє єдине володіння даними, що він містить. То що ж відрізняє `RefCell<T>` від типу на кшталт `Box<T>`? Згадайте правила позичання, які ви вивчили у Розділі 4:

* У будь-який час можна мати *або* одне мутабельне посилання, <0>або</0> будь-яку кількість немутабельних посилань.
* Посилання завжди мають бути коректними.

За допомогою посилань і `Box<T>` інваріанти правил позичання забезпечуються під час компіляції. За допомогою `RefCell<T>`, ці інваріанти забезпечуються *під час виконання*. При застосуванні посилань, якщо ви порушите ці правила, то отримаєте помилку компілятора. При застосуванні `RefCell<T>`, якщо ви порушите ці правила, ваша програма запанікує і завершиться.

Перевага перевірки правил позичання під час компіляції полягає в тому, що помилки будуть виявлені раніше під час розробки і немає впливу на продуктивність часу виконання, бо весь аналіз проведений заздалегідь. З цих причин перевірка правил позичання під час компіляції є найкращим вибором у більшості випадків, чому це і є замовчуванням Rust.

Перевагою перевірки правил позичання під час виконання є те, що уможливлюються певні безпечні для пам'яті сценарії, які були б заборонені перевірками часу компіляції. Статичний аналіз, як і компілятор Rust, за своєю природою консервативний. Певні властивості коду неможливо виявити лише аналізом коду: найвідоміший приклад - Проблема зупинки, про яку в цій книзі не йдеться, але це цікава тема для дослідження.

Оскільки певний аналіз неможливий, то якщо компілятор Rust не може бути впевненим, що код відповідає правилам володіння, він може відхилити коректну програму; таким чином, він консервативний. Якби Rust прийняв некоректну програму, користувачі не змогли б довіряти гарантіям, забезпеченим Rust. Однак, якщо Rust відхиляє правильну програму, програмісту буде незручно, але нічого катастрофічного не може станеться. Тип `RefCell<T>` є корисним, коли ви впевнені, що ваш код слідує правилам запозичень, але компілятор не в змозі зрозуміти і гарантувати це.

Подібно до `Rc<T>`, `RefCell<T>` призначено лише для використання в однопотоковому сценарії видасть вам помилку часу компіляції, якщо ви спробуєте використати його в багатопотоковому контексті. Ми поговоримо про те, як отримати функціональність `RefCell<T>` в багатопотоковій програмі у Розділі 16.

Ось коротке зведення, коли обирати `Box<T>`, `Rc<T>`, або `RefCell<T>`:

* `Rc<T>` дозволяє декілька власників одних даних; `Box<T>` і `RefCell<T>` мають одного власника.
* `Box<T>` дозволяє немутабельні чи мутабельні позичання, перевірені під час компіляції; `Rc<T>` дозволяє лише немутабельні позичання, перевірені під час компіляції; `RefCell<T>` дозволяє немутабельні чи мутабельні позичання, перевірені під час виконання.
* Оскільки `RefCell<T>` дозволяє мутабельні позичання, перевірені під час виконання, ви можете змінити значення всередині `RefCell<T>`, навіть коли `RefCell<T>` є немутабельним.

Зміна значення всередині немутабельного значення - це шаблон *внутрішньої мутабельності*. Подивімося на ситуацію, в якій внутрішня мутабельність корисна і дослідимо, як її використовувати.

### Внутрішня мутабельність: мутабельне позичання немутабельного значення

З правил запозичення випливає, що якщо ви маєте немутабельне значення, то ви не можете його мутабельно позичити. Наприклад, цей код не компілюється:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/no-listing-01-cant-borrow-immutable-as-mutable/src/main.rs}}
```

Якби ви спробували скомпілювати цей код, то отримали б таку помилку:

```console
{{#include ../listings/ch15-smart-pointers/no-listing-01-cant-borrow-immutable-as-mutable/output.txt}}
```

Проте, Існують ситуації, в яких було б зручним для значення змінювати себе у своїх методах, але виглядати немутабельним для іншого коду. Код за межами методів цього значення не має можливості змінювати значення. Використання `RefCell<T>` є одним зі способів отримати можливість внутрішньої мутабельності, але `RefCell<T>` не повністю оминає правила позичання: borrow checker у компіляторі дозволяє цю внутрішню мутабельність, і правила позичання перевіряються під час виконання програми. Якщо ви порушите ці правила, ви отримаєте `panic!` замість помилки компілятора.

Пропрацюємо практичний приклад, де ми можемо використати `RefCell<T>` для зміни немутабельного значення і побачити, чому це корисно.

#### Сценарій використання внутрішньої мутабельності: імітаційні об'єкти

Іноді під час тестування програміст може використовувати тип замість іншого типу, для того, щоб отримати певну поведінку та перевірити коректність його реалізації. Такий тип-замінник зветься *тест-дублером*. Можна розглядати його як "дублера-каскадера" у фільмі, де інша людина замінює актора для виконання певної ризикованої сцени. Тест-дублери замінюють інші типи при виконанні тестів. *Імітаційні об'єкти* - це спеціальні типи тест-дублерів, що записують, що відбувається під час тесту, щоб ви могли перевірити, що мали місце правильні дії.

У Rust немає об'єктів у тому ж сенсі, в якому вони є в інших мовах, і в Rust немає вбудованої функціональності імітаційних об'єктів у стандартній бібліотеці, як в деяких інших мовах. Однак, ви точно можете створити структуру, що буде служити тій же меті, що й імітаційний об'єкт.

Ось цей сценарій ми будемо тестувати: ми створимо бібліотеку, яка буде відстежувати значення до максимального значення і надсилатиме повідомлення залежно від того, наскільки близьке поточне значення до максимального значення. Цю бібліотеку можна використовувати, наприклад, для відстеження квоти користувача на кількість викликів API, які їм дозволено зробити.

Наша бібліотека забезпечить тільки функціональність відстеження, наскільки близьким до максимального є значення і коли та якими мають бути повідомлення. Очікується, що застосунки, які використовують нашу бібліотеку, забезпечать механізм відправлення повідомлень: застосунок може відправити повідомлення у застосунок, надіслати електронного листа, текстове повідомлення або щось інше. Бібліотека не має знати про такі подробиці. Все, що їй потрібно - щось, що реалізує наданий нами трейт, що зветься `Messenger`. Блок коду 15-20 показує код бібліотеки:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-20/src/lib.rs}}
```


<span class="caption">Блок коду 15-20: бібліотека для відстеження наближення значення до максимального значення і попередження, коли значення сягає певних рівнів</span>

Важливою частиною цього коду є те, що трейт `Messenger` має один метод, що зветься `send`, який приймає немутабельне посилання на `self` і текст повідомлення. Цей трейт є інтерфейсом нашого імітаційного об'єкта, який треба реалізувати, щоб імітаційний об'єкт можна було використовувати так само, як і реальний об'єкт. Іншою важливою частиною є те, що ми хочемо перевірити поведінку методу `set_value` у `LimitTracker`. Ми можемо змінити значення, що передається як параметр `value`, але `set_value` не поверне нам нічого, на чому можна робити тестові твердження. Ми хочемо мати змогу сказати, що якщо ми створюємо `LimitTracker` з чимось, що реалізує трейт `Messenger` і конкретним значенням `max`, то коли ми передаємо різні числа для `value`, месенджеру накажуть відправляти відповідні повідомлення.

Нам потрібен імітаційний об'єкт, який, замість того, щоб надіслати електронне або текстове повідомлення коли ми викликаємо `send`, лише стежитиме за повідомленнями, які йому сказано надіслати. Ми можемо створити новий екземпляр імітаційного об'єкта, створити `LimitTracker`, який використовує цей імітаційний об'єкт, викликати метод `set_value` для `LimitTracker` і перевірити, чи цей імітаційний об'єкт містить повідомлення, на які ми очікуємо. Блок коду 15-21 показує спробу реалізувати імітаційний об'єкт, що робить саме це, але borrow checker не дозволяє так робити:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-21/src/lib.rs:here}}
```


<span class="caption">Блок коду 15-21: спроба реалізувати `MockMessenger`, не дозволена borrow checker</span>

Код цього тесту визначає структуру `MockMessenger`, що має поле `sent_messages` з `Vec`, що складається з `String`, щоб відстежувати повідомлення, які йому сказано. відправити. Ми також визначили асоційовану функцію `new`, щоб зручно було створювати нові значення `MockMessenger`, які на початку мають порожній список повідомлень. Далі ми реалізуємо трейт `Messenger` для `MockMessenger`, щоб можна було передати `Messenger` до `LimitTracker`. У визначенні методу `send` ми беремо повідомлення, передане як параметр, і у `MockMessenger` зберігаємо його у списку `sent_messages`.

У цьому тесті ми тестуємо, що відбувається, коли наказали `LimitTracker` встановити якесь значення `value`, більше за 75 відсотків значення `max`. Спочатку ми створюємо новий `MockMessenger`, який починає з порожнім списком повідомлень. Далі ми створюємо новий `LimitTracker` і даємо йому посилання на новий `MockMessenger` і значення `max` 100. Ми викликаємо метод `set_value` для `LimitTracker` зі значенням 80, що більше, ніж 75% від 100. Далі ми твердимо, що список повідомлень, який відстежує `MockMessenger`, має тепер складатися з одного повідомлення.

Однак, є одна проблема з цим тестом, як показано тут:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-21/output.txt}}
```

Ми не можемо змінити `MockMessenger` для відстеження повідомлень, оскільки метод `send` приймає немутабельне посилання на `self`. Також ми не можемо скористатися пропозицією з тексту помилки замінити посилання на `&mut self`, тому що тоді сигнатура `send` не відповідатиме сигнатурі у визначенні трейту `Messenger`: (можете спробувати і побачите, яке повідомлення про помилку ви отримаєте).

У цій ситуації може допомогти внутрішня мутабельність! Ми зберігатимемо `sent_messages` в `RefCell<T>`, і тоді метод `send` зможе змінити `sent_messages`, щоб зберегти повідомлення, які ми бачили. Блок коду 15-22 показує, як це виглядає:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-22/src/lib.rs:here}}
```


<span class="caption">Блок коду 15-22: Використання `RefCell<T>`, щоб змінити внутрішнє значення, поки зовнішнє значення вважається немутабельним</span>

Поле `sent_messages` тепер має тип `RefCell<Vec<String>>`, а не `Vec<String>`. У функції `new` ми створюємо новий екземпляр `RefCell<Vec<String>>` навколо порожнього вектора.

Для реалізації метода `send` перший параметр все ще є немутабельним позичанням `self`, що відповідає за визначенню трейта. Ми викликаємо `borrow_mut` для `RefCell<Vec<String>>` у `self.sent_messages`, щоб отримати мутабельне посилання на значення всередині `RefCell<Vec<String>>`, тобто вектор. Тоді ми можемо викликати `push` для мутабельного посилання на вектор, щоб зберігати повідомлення, надіслані протягом тесту.

Остання зміна, яку ми повинні зробити - в твердженні тесту: щоб подивитись, скільки елементів є у внутрішньому векторі, ми викликаємо `borrow` для `RefCell<Vec<String>>`, щоб отримати немутабельне посилання на вектор.

Тепер, коли ви побачили, як використовувати `RefCell<T>`, зануримось у те, як воно працює!

#### Відстеження позичань за допомогою `RefCell<T>` під час виконання

Створюючи немутабельні і мутабельні посилання, ви використовуємо, відповідно, записи `&` та `&mut`. Для `RefCell<T>` ми використовуємо методи `borrow` і `borrow_mut`, які є частиною безпечного API `RefCell<T>`. Метод `borrow` повертає розумний вказівник типу `Ref<T>`, а `borrow_mut` повертає розумний вказівник типу `RefMut<T>`. Обидва типи реалізують `Deref`, тому ми можемо працювати з ними як зі звичайними посиланнями.

`RefCell<T>` відстежує, скільки є активних розумних вказівників `Ref<T>` і `Refut<T>` у кожен момент. Кожного разу коли ми викликаємо `borrow`, `RefCell<T>` збільшує кількість активних немутабельних позичань. Коли значення `Ref<T>` виходить з області видимості, кількість немутабельних позичань зменшується на один. Так само як правила позичання часу компіляції, `Refell<T>` дозволяє мати багато немутабельних позичань або одне мутабельне позичання в будь-який момент часу.

Якщо ми спробуємо порушити ці правила, то замість помилки компілятора, як це стається з посиланнями, реалізація `RefCell<T>` запанікує під час виконання. Блок коду 15-23 показує зміну реалізації `send` з Блоку коду 15-22. Ми навмисно намагаємося створити два немутабельні позичання активними в одній області видимості, щоб продемонструвати, що `RefCell<T>` запобігає цьому під час виконання.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,panics
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-23/src/lib.rs:here}}
```


<span class="caption">Блок коду 15-23: створення двох мутабельних посилань в одній області видимості, щоб побачити, що`RefCell<T>` запанікує</span>

Ми створюємо змінну `one_borrow` для розумного вказівника `RefMut<T>`, повернутого з `borrow_mut`. Потім так само створюємо ще одне мутабельне позичання в змінній `two_borrow`. Це створює два мутабельні позичання в одній області видимості, що є забороненим. Коли ми запускаємо тести для нашої бібліотеки, код з Блоку коду 15-23 скомпілюється без будь-яких помилок, але тест не провалиться:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-23/output.txt}}
```

Зверніть увагу, що код панікував з повідомленням `already borrowed:
BorrowMutError`. Ось так `RefCell<T>` обробляє порушення правил позичання під час виконання.

Перехоплення помилок під час виконання, а не під час компіляції, як ми зробили це тут, означає що ви потенційно знаходитимете помилки у вашому коді пізніше під час розробки. Можливо, лише тоді, коли ваш код уже буде розгорнуто у кінцевого користувача. Крім того, ваш код матиме незначне зниження продуктивності у піл час виконання у результаті відстеження позичань під час виконання замість часу компіляції. Проте використання `RefCell<T>` уможливлює запис імітаційних об'єктів, які можуть змінювати себе, щоб відстежувати повідомлення, які вони отримували під час використання в контексті, де допускаються лише немутабельні значення. Ви можете використовувати `RefCell<T>` не зважаючи на його недоліки, щоб отримати більше функціональності, ніж надають звичайні посилання.

### Множинні власники мутабельних даних за допомогою комбінації `Rc<T>` та `RefCell<T>`

Звичайний спосіб використання e `RefCell<T>` - комбінація з `Rc<T>`. Згадайте, що `Rc<T>` дозволяє мати кілька володільців одних даних, але надає лише немутабельний доступ до цих даних. Якщо ви маєте `Rc<T>`, що містить `RefCell<T>`, ви можете отримати значення, що може мати кількох власників *і* яке ви можете змінювати!

Наприклад, згадайте приклад зі списком cons у Блоці коду 15-18, де ми використовували `Rc<T>`, щоб дозволити декільком спискам ділитися володінням іншим списком. Оскільки `Rc<T>` має лише немутабельні значення, ми не можемо змінити жодне зі значень у списку після їх створення. Додамо `RefCell<T>`, щоб отримати можливість змінити значення у списках. Блок коду 15-24 показує, що використовуючи `Refell<T>` у визначенні `Cons` ми можемо змінити значення, збережене у всіх списках:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#include ../listings/ch15-smart-pointers/listing-15-24/main.rs}}
```


<span class="caption">Блок коду 15-24: використання `Rc<RefCell<i32>>` для створення `List`, який ми можемо змінювати</span>

Ми створюємо значення, що є екземпляром `Rc<RefCell<i32>>`, і зберігаємо його у змінній з назвою `value`, щоб пізніше мати можливість доступу до нього. Потім створили `List` в `a` з варіантом `Cons`, що містить `value`. Ми маємо клонувати `value`, щоб обидва `a` і `value` мали володіння над внутрішнім значенням `5` замість передачі володіння з `value` до `a` чи щоб `a` позичало `value`.

Ми обгорнули список `a` у `Rc<T>`, тож коли ми створюємо списки `b` та `c`, вони обидва можуть посилатися на `a`, як ми робили у Блоці коду 15-18.

Після створення списків у `a`, `b`і `c`, ми хочемо додати 10 до значення в `value`. Ми зробимо це, викликавши `borrow_mut` для `value`, що використовує автоматичне розіменування, обговорене в Розділі 5 (див. підрозділ ["А де ж оператор `->`?"][wheres-the---operator]<!-- ignore -->), для розіменування `Rc<T>` до внутрішнього значення `RefCell<T>`. Метод e `borrow_mut` повертає розумний вказівник `RefMut<T>`, і ми використовуємо на ньому оператор розіменування та змінюємо внутрішнє значення.

Коли ми виводимо `a`, `b` та `c`, ми бачимо, що всі вони мають змінене значення 10 замість 5:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-24/output.txt}}
```

Ця техніка дуже акуратна! Використовуючи `RefCell<T>`, ми маємо зовнішньо немутабельне значення `List`. Але ми можемо використати методи `RefCell<T>`, які надають доступ до його внутрішньої мутабельності, тож ми можемо змінювати наші дані в разі потреби. Перевірка правил запозичення часу виконання захищає нас від гонитви даних, і це іноді варто виміняти на крихту швидкості швидкістю заради цієї гнучкості в наших структурах даних. Зверніть увагу, що `RefCell<T>` не працює в багатопотоковому коді! `Mutex<T>` є потоково-безпечною версією `Refell<T>`, і ми обговоримо `Mutex<T>` в Розділі 16.

[wheres-the---operator]: ch05-03-method-syntax.html#wheres-the---operator
