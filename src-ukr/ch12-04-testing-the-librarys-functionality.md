## Розробка Функціонала Бібліотеки із Test-Driven Development

Тепер, коли ми перенесли логіку в *src/lib.rs* та залишили збір аргументів та обробку помилок в *src/main.rs*, стало набагато простіше писати тести для основного функціонала нашого коду. Ми можемо викликати функції напряму із різноманітними аргументами та перевіряти повернуті значення без потреби виклику нашого двійкового файлу із командного рядка.

У цій секції ми додамо пошукову логіку до програми `minigrep`, використовуючи стиль розробки через тестування (TDD) із наступними кроками:

1. Напишіть тест, який дає збій і запустить його, щоб переконатися, що він це робить через очікувану причину.
2. Напишіть або змініть мінімум коду, щоб новий тест пройшов.
3. Відрефакторіть щойно доданий або змінений код та впевніться, що тести продовжують проходити.
4. Повторіть з першого кроку!

Хоча це лише один з багатьох способів написання програмного забезпечення, TDD може допомагати надавати потрібного напрямку оформленню коду. Створення тесту перед тим, як написати код, який забезпечить проходження тесту, допомагає підтримувати високий рівень покриття тестуванням протягом всього процесу розробки.

Ми протестуємо імплементацію функціоналу який буде робити пошуковий запит стрічки у вмісті файлу та створювати список рядків, які відповідають запиту. Ми додамо цей функціонал у функцію під назвою `search`.

### Написання Провального Тесту

Видалімо інструкції `println!` які ми використовували для перевірки поведінки програми з *src/lib.rs* та *src/main.rs*, бо нам вони більше не потрібні. Потім додамо в *src/lib.rs* модуль `tests` із тестовою функцією, як ми зробили в [Розділі 11][ch11-anatomy]<!-- ignore -->. Тестова функція визначає бажану поведінку функції `search`: вона отримає запит та текст для пошуку, і вона буде повертати лише рядки з тексту, які містять запит. Блок коду 12-15 показує цей тест, який ще не компілюється.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-15/src/lib.rs:here}}
```


<span class="caption">Блок коду 12-15: Створення невдалого тесту для функції `search`, яку ми хотіли б мати</span>

Цей тест шукає рядок `"duct"`. Текст, в якому ми робимо пошук, це три рядки, лише один з яких містить `"duct"` (Зауважте, що зворотний слеш після першої подвійної лапки каже Rust не розміщувати символ нового рядку на початку цієї стрічки). Ми стверджуємо, що значення, повернене з функції `search` містить тільки рядки, які ми очікуємо.

Ми ще не готові запустити цей тест та подивитися, як він дає збій, бо тест навіть не компілюється: функція `search` ще не існує! Згідно з принципами TDD, ми додамо лише мінімум коду, щоб тест почав компілюватися та виконуватися, додав визначення функції `search`, яке завжди повертає порожній вектор, як показано в Блоці коду 12-16. Тоді тест повинен скомпілюватися та провалитися, бо порожній вектор не зіставляється з вектором, який містить рядок `"safe, fast, productive."`

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-16/src/lib.rs:here}}
```


<span class="caption">Блок коду 12-16: Визначення функції `search`, якого досить для проходження тесту</span>

Зауважте, що нам потрібно явно визначити час існування `'a` в сигнатурі `search` та використати цей час існування з аргументом `contents` та поверненим значенням. Згадаємо [Розділ 10][ch10-lifetimes]<!-- ignore --> де час існування параметрів вказував, який час існування аргументу пов'язаний з поверненим значенням. У цьому випадку, ми вказуємо, що повернутий вектор має містити слайси стрічки, які посилаються на слайси аргументу `contents` (замість аргументу `query`).

Інакше кажучи, ми повідомляємо Rust, що дані, отримані `search` функцією будуть існувати допоки вони передаються в `search` функцію аргументом `contents`. Це важливо! Дані, на які посилається *слайс* мають бути валідними, щоб посилання було валідним; якщо компілятор вважає, що ми робимо строкові слайси `query` замість `contents`, він зробить перевірку безпеки некоректно.

Якщо ми забудемо анотації часу існування і спробуємо скомпілювати цю функцію, ми отримаємо цю помилку:

```console
{{#include ../listings/ch12-an-io-project/output-only-02-missing-lifetimes/output.txt}}
```

Rust не має можливості дізнатися, який з двох аргументів нам потрібен, тому ми маємо явно це вказати. Оскільки `contents` це аргумент, який містить увесь наш текст і ми хочемо повертати відповідні частини цього тексту, ми розуміємо, що `contents` це аргумент який має бути пов'язаний з поверненим значенням використовуючи синтаксис часу існування.

Інші мови програмування не вимагають від вас пов'язувати аргументи із поверненим значенням в сигнатурі функції, але ця практика з часом стане легшою. Ви можете захотіти порівняти цей приклад із [“Validating References with Lifetimes”]()<!-- ignore --> Розділу 10.

Тепер запустимо тест:

```console
{{#include ../listings/ch12-an-io-project/listing-12-16/output.txt}}
```

Чудово, тест провалюється, як ми й очікували. Нумо зробимо тест, який пройде!

### Написання Коду для Проходження Тесту

Наразі наш тест провалюється, бо він завжди повертає порожній вектор. Щоб виправити це та імплементувати `search`, наша програма має виконати такі дії:

* Ітерувати через кожний рядок вмісту.
* Перевірити, чи містить цей рядок нашу стрічку запиту.
* Якщо так, то додати його до списку значень який ми повертаємо.
* Якщо ні, то нічого не робити.
* Повернути отриманий список рядків, які збігаються.

Пройдімо кожен крок, починаючи з ітерації по рядках.

#### Ітерація над Рядками із Методом `lines`

Rust має корисний метод для керування ітерацією по стрічці рядок за рядком який зручно названий `lines`, який працює як показано в Блоці Коду 12-17. Зверніть увагу, це ще не буде компілюватися.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-17/src/lib.rs:here}}
```


<span class="caption">Блок коду 12-17: Ітерація по кожному рядку в `contents` </span>

Метод `lines` повертає ітератор. Ми поговоримо про ітератори більш детально в [Розділі 13][ch13-iterators]<!-- ignore -->, але пригадайте, що ви бачили цей спосіб використання ітератора в [Блоці Коду 3-5][ch3-iter]<!-- ignore -->, де ми використовували цикл `for` з ітератором для виконання деякого коду на кожному елементі колекції.

#### Пошук Запиту в Кожному Рядку

Далі, ми перевіримо, чи містить поточний рядок стрічку запиту. На щастя, стрічки мають корисний метод названий `contains`, який робить це для нас! Додайте виклик методу `contains` в функцію `search`, як показано в Блоці Коду 12-18. Зауважте, що це ще не буде компілюватися.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-18/src/lib.rs:here}}
```


<span class="caption">Блок коду 12-18: Додавання перевірки наявності `query` в рядку</span>

Ми зараз створюємо функціонал. Щоб він компілювався, нам потрібно повертати значення з вмісту функції, як ми вказали в її сигнатурі.

#### Зберігання Відповідних Рядків

Щоб завершити цю функцію, нам потрібен спосіб зберігання зіставлених рядків, які ми хочемо повертати. Для цього, ми можемо створити мутабельний вектор перед циклом `for` та викликати метод `push`, щоб зберегти `line` в векторі. Після циклу `for`, ми повертаємо вектор, як показано в Блоці Коду 12-19.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-19/src/lib.rs:here}}
```


<span class="caption">Listing 12-19: Storing the lines that match so we can return them</span>

Тепер функція `search` повинна повертати тільки рядки, що містять `query`, і наш тест повинен пройти. Запустимо тест:

```console
{{#include ../listings/ch12-an-io-project/listing-12-19/output.txt}}
```

Наш тест пройшов, тому ми знаємо, що він працює!

На цьому етапі ми могли б розглянути можливості рефакторингу імплементації функції пошуку, зберігаючи проходження тестів та зберігаючи той самий функціонал. Код функції пошуку не настільки й поганий, але він не використовує переваги деяких корисних особливостей ітераторів. Ми повернемось до цього прикладу в [Розділі 13][ch13-iterators]<!-- ignore -->, де ми дослідимо ітератори детальніше та розглянемо, як ми можемо їх вдосконалити.

#### Використання Функції `search` в Функції `run`

Тепер, коли функція `search` працює та протестована, нам потрібно викликати `search` з нашої функції `run`. Нам потрібно передати значення `config.query` та `contents` яке `run` читає з файлу в функцію `search`. Потім `run` виведе в консолі кожен рядок повернений з `search`:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/no-listing-02-using-search-in-run/src/lib.rs:here}}
```

Ми досі використовуємо цикл `for` для повернення кожного рядка із `search` та його виводу в консолі.

Тепер вся програма має працювати! Нумо спробуємо, спочатку зі словом, яке має повертати річно один рядок із поеми Емілі Дікінсон, "frog":

```console
{{#include ../listings/ch12-an-io-project/no-listing-02-using-search-in-run/output.txt}}
```

Круто! Спробуємо слово, яке зіставлятиметься з кількома рядками, наприклад "body":

```console
{{#include ../listings/ch12-an-io-project/output-only-03-multiple-matches/output.txt}}
```

І, нарешті, переконаймось, що ми не отримуємо жодних рядків, коли ми шукаємо слово, якого немає ніде в поемі, наприклад, "monomorphization":

```console
{{#include ../listings/ch12-an-io-project/output-only-04-no-matches/output.txt}}
```

Блискуче! Ми побудували нашу власну мініверсію класичного інструменту та багато дізналися про структурування застосунків. Ми також дізналися дещо про ввід у файл, вивід файлу, часи існування, тестування та парсинг командного рядка.

To round out this project, we’ll briefly demonstrate how to work with environment variables and how to print to standard error, both of which are useful when you’re writing command line programs. ch10-03-lifetime-syntax.html#validating-references-with-lifetimes
ch10-03-lifetime-syntax.html#validating-references-with-lifetimes

[ch11-anatomy]: ch11-01-writing-tests.html#the-anatomy-of-a-test-function
[ch10-lifetimes]: ch10-03-lifetime-syntax.html
[ch3-iter]: ch03-05-control-flow.html#looping-through-a-collection-with-for
[ch13-iterators]: ch13-02-iterators.html
