# Керування зростаючими проектами за допомогою Пакетів, Крейтів та Модулів

Що більші програми ви пишете, то більшого значення набуває організація коду. Групуючи повʼязаний функціонал і відділяючи код з не повʼязаними функціями, ви вносите ясність, де шукати код, що реалізовує певний функціонал і де вносити зміни до нього.

Програми, які ми написали раніше, поки знаходилися в одному модулі в єдиному файлі. По мірі зростання проекту вам слід організовувати код, розбиваючи його на кілька модулів і декілька файлів. Пакет може містити багато бінарних крейтів і, опціонально, одну бібліотеку-крейт. Зі зростанням пакету ви можете виділяти його частини в окремі крейти, що стають зовнішніми залежностями. Цей розділ висвітлює усі ці техніки. Для дуже великих проектів, які містять взаємоповʼязані пакети, що розвиваються разом, Cargo надає робочі простори (workspaces), які  будуть висвітлені у розділі \["Робочі простори Cargo"\]\[workspaces\]<!-- ignore --> Розділу 14.

Ми також обговоримо інкапсуляцію деталей реалізації, що дозволяє повторно використовувати код на більш високому рівні: щойно ви реалізували операцію, інший код може викликати ваш код через публічний інтерфейс, навіть не знаючи деталей реалізації. Ваш підхід до написання коду визначає, які частини програми є публічними для використання іншим кодом, а які є приватними, деталі реалізації яких ви б хотіли приховати. Це ще один спосіб обмеження кількості деталей, які вам потрібно тримати в голові.

Повʼязане поняття - область видимості (scope): вкладенний контекст, в якому написаний код, має набір імен, що визначаються як "в області видимості". При читанні, написанні і компілюванні коду, програмісти та компілятори мають знати, чи певне імʼя в певному місці відноситься до змінної, функції, структури, переліку, модулю, константи або іншого елементу і що саме цей елемент означає. Ви можете створювати області видимості та визначати, які імена належать до них, а які ні. Але не можна мати два елементи з однаковою назвою в одній області видимості. Існують інструменти для вирішення конфліктів імен.

Rust має ряд функцій, що дозволяють керувати організацією коду, як-то тим, які деталі робити публічними, які приватними, які імена будуть в кожній області видимості вашої програми. Ці функції, які інколи називають *модульною системою*, включають в себе:

* **Пакети:** Функціонал Cargo, що дозволяє збирати, тестувати і поширювати крейти
* **Крейти:** Дерево модулів, що створює бібліотеку або виконуваний файл
* **Модулі** та **use:** Дозволюять контролювати організацією, областю видимості та приватністю шляхів
* **Шляхи:** Спосіб іменування елемента, як-то структура, функція або модуль

В цьому розділі ми розглянемо всі ці функції, подивимось як вони взаємодіють і пояснимо як їх використовувати для керування областю видимості. В результаті у вас має бути ґрунтовне розуміння модульної системи та здатність працювати з областями видимості на рівні професіоналів!
