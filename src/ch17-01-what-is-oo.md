## Характеристики об'єктно орієнтованого програмування

Спільнота програмістів не дійшла згоди в питані того, що повинна містити мова, 
щоб вважатися об'єктно орієнтовано. Багато парадигм програмування знаходять 
своє відображення в мові Rust. В цей список входить ООП також. З іншою 
парадигмою ви вже зустрічалися в частині 13. Беззаперечно ООП мови містять в 
собі деякі спільні характеристики: об'єкти, інкапсуляцію і наслідування. Тож 
розгляньмо, що кожна з цих характиристик значить і як Rust її підтримує.

### Об'єкти, котрі місять дані та поведінку

Книга Еріха Гамми, Річарда Гелма, Ральфа Джонсона і Джона Вліссайдса *Design 
Patterns: Elements of Reusable Object-Oriented Software(Addison-Wesley
Professional, 1994)*, яку в розмовній мові називають книгою *Банди Чотирьох*,
є каталогом шаблонів об'єктно орієнтованого дизайну. В книзі ООП визначається 
наступним способом:

> Об'єктно орієнтовані прогарми складаються з об'єктів. *Об'єкт* формується як 
> даними, так і процедурами, котрі працюють з цими даними. Цими процедурами є 
> так звані *методи* або *операції*.

Користуючись цим визначенням, Rust є об'єктно орієнтованим: структури і енуми 
містять дані, а `impl` блок дозволяє реалізовувати методи для структур і 
енамів. Не зважаючи на те, що структури і енами з методами не *називаюить*
об'єктами, вони містять той самий функціонал, що і об'єкти згідно з визначенням
Банди Чотирьох.

### Інкапсуляція, яка приховує деталі реалізації

Іншим аспектом, який часто асоціюють з ООП, є ідея *інкапсуляції*. Головною 
ідеєю цього аспекту є те, що деталі реалізації об'єкту не є доступними з коду, 
який цей об'єкт користує. З цього випливає, що єдиним способом взаємодії з 
об'єктом є його публічне АПІ; код, який використовує об'єкт, не повинен мати 
можливості прямого доступу до даних об'єкту, його внутрішнього стану 
чи безпосередньої зміни поведінки об'єкту. Це дозволяє програмісту змінювати і 
рефакторити внутрішній код об'єкту без необхідності зміни коду, який 
використовує об'єкт.

Ми обговорили як контролювати інкапсуляцію в розділі 7: ми можемо 
використовувати ключове слово `pub`, щоб визначити, які модулі, типи, функції 
і методи нашого коду повинні бути публічними. Усталено все є приватним. 
Наприклад: ми можемо визначити структуру `AveragedCollection`, котра містить 
поле -- вектор значень `i32`. Структура також може містити поле, яке зберігає 
середнє значення в векторі, що дозволяє не перераховувати середнє значення 
кожен раз, коли хтось його запросить. Іншими словами `AveragedCollection` буде 
кешувати підраховане середнє значення для нас. В роздруківці 17-1 міститься 
декларація структури `AveragedCollection`:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch17-oop/listing-17-01/src/lib.rs}}
```

<span class="caption">Роздруківка 17-1: `AveragedCollection` структура, що 
містить список цілих чисел і середнє значення контейнеру</span>

Структура позначена `pub`, щоб інший код міг її використати, але поля 
залишаються приватними. Це важливо, оскільки ми хочемо гарантувати, що коли б 
ми не додали чи забрали якесь значення зі списку -- середнє значення теж 
оноввилось. Ми досягаємо цього реалізуючи методи `add`, `remove`, і `average` 
структури так, як показано в роздруківці 17-2:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch17-oop/listing-17-02/src/lib.rs:here}}
```

<span class="caption">Роздруківка 17-2: Реалізація публічних методів `add`, 
`remove`, and `average` для `AveragedCollection`</span>

Публічні методи `add`, `remove` і `average` є єдиним способом щоб отримати 
доступ чи модифікувати екземпляр `AveragedCollection`. Коли ми додаємо елемент 
до `list` з допомогою методу `add` чи видаляємо методом `remove`, реалізація 
всіх методів викличе приватний метод `update_average`, який обробить зміну 
середнього значення.

Ми залишаємо поля `list` і `average` приватними, щоб не було іншого способу 
отримати доступ до них напряму. В іншому випадку, полу `average` може стати виявитися 
не синхронізованим з полем `list`. Метод `average` повертає значення, яке міститься в 
полі `average`, дозволяючи користувачам структури прочитати середнє значення, але не 
модифікувати його.

Оскільки ми інкапсулювали деталі реалізації структури `AveragedCollection`, ми 
без проблем можемо змінити аспекти реалізації структури в майбітньому. 
Наприклад, ми можемо використати `HashSet<i32>` замість `Vec<i32>` для поля 
`list`. Доки сигнатура публічних методів `add`, `remove`і `average` залишається 
незмінною, використання `AveragedCollection` не потрібно буде змінювати. Якби 
ми зробили `list` публічним, можливо б довелося змінювати спосіб взаємодії з 
структурою: `HashSet<i32>` і `Vec<i32>` мають різні способи додавання і 
видалення елементів, тому користувачеві структури, скоріше за все, довелося б 
змінювати використання структури `list`.

Якщо інкапсуляція є обов'язковим аспектом для об'єкто орієнтованої мови, то 
Rust можна вважати такою. Наявність чи відсутність rлючового слова `pub` 
дозволяє інкапсулювати деталі реалізації.

### Наслідування як система типів, а також як система спільного використання коду

*Наслідування* — це механізм, за допомогою якого об’єкт може успадковувати 
елементи з визначення іншого об’єкта, таким чином отримуючи дані та поведінку 
батьківського об’єкта без потреби визначати їх знову.

Якщо мова повинна мати наслідування, щоб бути об’єктно орієнтованою, то Rust не
є нею. Тут нема способу визначити структуру, яка успадковує поля та реалізації 
методів батьківської структури, без використання макросу.

Однак, якщо ви звикли мати успадкування у своєму наборі інструментів 
програмування, ви можете використовувати інші рішення в Rust, залежно від того, 
чому ви спочатку звернулися до успадкування.

Є дві основні причини, щоб використовувати наслідування: Перша з них, це щоб 
перевикористати код: ви можете реалізувати поведінку для якогось одного типа, 
а наслідування дозволить вам перевикористати реалізацію для іншого типу. Ви 
можете використати обмежену версію цього підходу в Rust, з допомогою усталеної 
реалізації трейту, яку ви бачили в роздруківці 10-14, коли ми додали усталену 
реалізацію методу `summarize` для трейту `Summary`. Любий тип, який реалізовує 
трейт `Summary` матиме доступним метод `summarize` без повторного написання 
коду. Це є схожим до батьківського класу, який містить реалізацію методу, і 
дочірнього класу, який унаслідує реалізацію цього ж методу. Також у випадках 
реалізації трейту `Summary`, ми можемо перевизначити усталену реалізацію методу 
`summarize` власною, що схоже до перевизначення батьківського методу в 
дочірньому класі.

Інша причина використання наслідування пов’язана з системою типів: дозволяти 
використовувати дочірній тип в тих місцях, де очікується батьківський тип. Це 
також називається *поліморфізмом*, що означає, що ви можете без проблем 
замінити один об'єкт на інший, якщо той задовольняє певні вимоги.

> ### Поліморфізм
>
> Для багатьох людей поліморфізм є синонімом до наслідування. Але це більш 
> загальний концепт, що описує код, який працює з декількома типами. При 
> наслідуванні ці типи повинні бути підкласами
>
> Взамін, Rust використовує абстрактний тип для абстрагування над різними 
> можливими типами та трейтами, щоб накласти обмеження на те, що мають надавати 
> ці типи. Це іноді називають *обмеженим параметричним поліморфізмом*. 

Останнім часом, програмісти почали значно рідше використовувати наслідування, 
оскільки наявний великий ризик перевикористання більше коду ніж необхідно. 
Підкласи не завжди повинні мати всі ті ж самі характеристики, що й їхні батьки, 
однак ми завжди робимо так з наслідуванням. Це може зробити архітектуру програм 
менш гнучкою. Також це дозволяє викликати методи в класах, незважаючи на те, що 
цей метод не має сенсу в цьому класі. На додачу до цього, деякі мови 
забороняють множинне наслідування(іншими словами дочірній клас може мати тільки 
одного батька), що тільки зменшує гнучкість програм.

З цих причин Rust використовує інший підхід: використання трейтів замість 
успадкування. Давайте подивимося, як трейти забезпечують поліморфізм у Rust.